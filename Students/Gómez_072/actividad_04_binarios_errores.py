# -*- coding: utf-8 -*-
"""Actividad_04_Binarios_Errores.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MLcMDIzvRnblJdGXcKzWXUpRoa_m7ymU

>[Actividad 4](#scrollTo=6d26e874&uniqifier=1)

>>>[Apuntes del libro asociado a la temática](#scrollTo=2kwdp7kewzSL&uniqifier=1)

>>>[Activity 1.0:](#scrollTo=74f1131a&uniqifier=1)

>>>[Activity 2.0:](#scrollTo=e622b7b5&uniqifier=1)

>>>[Activity 3.0:](#scrollTo=d11e596d&uniqifier=1)

<a href="https://colab.research.google.com/github/hernansalinas/autogrades/blob/main/Actividades_clase/Actividad_04_Binarios_Errores.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>



# Actividad 4
Métodos computacionales para físicos  y astrónomos

Universidad de Antioquia

Prof: Hernan D. Salinas Jiménez
"""

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/hernansalinas/autogrades.git
#path="libs"
path="autogrades/Actividades_clase/libs"
# %run -i {path}/libUnitTest.py

"""###Apuntes del libro asociado a la temática"""

23e306 *100       #numeros muy largos son considerados como infinitos

3e-500  #numeros muy pequeños son considerados como cero

0.6666666666666666 - 0.6666666666666666123456789  #luego de 15 cifras decimales el cósigo descarta lo que sigue

import numpy as np

np.sqrt(2), np.sqrt(2)**2, np.sqrt(2)**2 -2    #notamos que al realizar operaciones que matematicamente son análogas, se presentan cierto tipo de errores en las cifras decimales (luego de 15)

#Podemos usar bin(), para determinar el correpondiente valor en numeros binarios

bin(47), bin(47)[2:], bin(47)[2:].rjust(8,'0')


#usamos el rjust para lograr que el numero binario en un formato de 8 bits

#también, es posible convertir un numero binario a un entero, cuando se escribe en el formato apropiado que recibe python
#la forma correcto de escribir el numero binario es que comience con 0b

int('0b101111',base=0), int('0b0000000101111',base=0)

#notamos que el resultado es el mismo si se añaden ceros luego del 0b y antes del numero binario que se quiere convertir a entero

#el siguiente código permite convertir numeros flotantes a su representacion binaria

import struct

def binary(num):
#num=3
#if True:
    # Struct can provide us with the float packed into bytes. The '!' ensures that
    # it's in network byte order (big-endian) and the 'f' says that it should be
    # packed as a float: 32 bites. Alternatively, for double-precision, you could use 'd'.
    packed = struct.pack('!f', num)
    print( 'Packed: %s' % repr(packed))

    # For each character in the returned string, we'll turn it into its corresponding
    # integer code point
    # 
    integers = [c for c in packed]
    print( 'Integers: %s' % integers)

    # For each integer, we'll convert it to its binary representation.
    binaries = [bin(i) for i in integers]
    print( 'Binaries: %s' % binaries)

    # Now strip off the '0b' from each of these
    stripped_binaries = [s.replace('0b', '') for s in binaries]
    print( 'Stripped: %s' % stripped_binaries)

    # Pad each byte's binary representation's with 0's to make sure it has all 8 bits:
    #
    # ['00111110', '10100011', '11010111', '00001010']
    padded = [s.rjust(8, '0') for s in stripped_binaries]
    print( 'Padded: %s' % padded)

    # At this point, we have each of the bytes for the network byte ordered float
    # in an array as binary strings. Now we just concatenate them to get the total
    # representation of the float:
    return ''.join(padded)

BIN=binary(0.15625)

BIN, ''.join( list(BIN)[::-1] ) #inverted list joined into a string

"""### Activity 1.0: 

Implement a function that get the binary representation of an integer with name mybin, the algorithm should return 
a string with 8 characters, the maximun number that represent the funcition is integer of 8 bit. The name of function is 
mybin

Ejexample : 

b=mybin(x)

b='00101000'
"""

##!/usr/bin/env python3

representacion=[]

def mybin(x):
    #print('__name__ = {}'.format(__name__))
    if x== 2:
      representacion.append('0')
      representacion.append('1')
      #print((''.join(representacion[::-1])).rjust(8,'0'))
      b=(''.join(representacion[::-1])).rjust(8,'0')
      return b    #unimos los elementos de representacion en un string, pero cuando la lista es alreves
    elif x== 3:
      representacion.append('1')
      representacion.append('1')
      #print((''.join(representacion[::-1])).rjust(8,'0'))
      b=(''.join(representacion[::-1])).rjust(8,'0')
      return b  
    else:
      s= x%2
      x= int(x//2)
      representacion.append(str(s))
      a = mybin(x)
      return a


mybin(246), bin(246)

#usamos esto para probar las funciones que se deben realizar
a= ['1', '2', '2']
b= a[::-1]
''.join(b)

#otra forma de hacerlo es utilizando un while

def mybin(x):
  b=''
  while x != 0:      #cuando el ultimo valor que queda en la division es uno, el residuo es cero, ese  ya no se tiene en cuenta
    oldx= x
    b = str(x%2)+b       #notamos que se va juntando de atras hacia delante
    x = x//2
  b = b.rjust(8,'0')
  return b

mybin(12)

# Commented out IPython magic to ensure Python compatibility.
# %run -i {path}/Act_02/test01.py

####observacion:   Se presenta corregido el primer código de recursión, tal que el return sea adecuado:

def m_bin(x):
  """Definimos la condicion de parada: 
  - Si el valor es  2 los  ultimos numeros seran "01".
  - Si el valor es 3 los ultimos numeros seran "11"
  No debemos poner una variable como  return dentro de la recursión, por que justamente
  lo que definimos es valor en los casos extremos.
  La recursin realizará s+m_bin(x) en cada instante, es decir concatenará los
  string. 
  """
  if(x==2):
    return "01"
  elif(x==3):    
    return "11"
  elif(x==1):
    return "1"
  else :            
    s = x%2
    x = int(x//2)
    return str(s) + m_bin(x)


def my_bin(x):
  """
  Como el resultado lo necesitamos invertir, 
  se hace    la inversion en una funcion aparte, 
  tambien lo puede reelizar dentro de la funcion anterior 
  empleando parentesis en el return y poniendo rjust(8,"0")
  """
  return m_bin(x)[::-1].rjust(8,'0')

"""### Activity 2.0: 

With the binary representation please try to implement the formula to recover the number.

Hint: Use as input the binary representation as a string and invert its order

```
number32(BIN):

```

Where BIN is a string with the binary number

Example: 


Test your solution for the next number:

number32("00111110001000000000001000010000")
"""

import numpy as np

def number32(BIN):

  #se crea una lista que contenga a cada uno de los digitos del numero proporcionado como un string
  #se convierten a un numpy array, y se asigna que el tipo de cada uno de los elementos del array sea un entero
    b_inverted= np.array(list(BIN)[::-1]).astype(int)  
  
  #el signo del numero va ser el último de la lista que hemos invertido
    s= b_inverted[-1]       

  #miramos ahora la parte exponencial
    be = b_inverted[23:31]
    i=  np.arange(8 )    #--> se puede poner en lugar de 8 un be.size
    e = (be * (2**i)).sum()

  #ahora, vamos a mirar la parte fraccional, la cual corresponde a los primeros 23 elementos de nuestra lista invertida
  #para hallar el valor de i de esta parte, se toman 23 valores pero alrevés, para hacer la sumatorias del denominador
    bf= b_inverted[:23]  
    i_inverted= np.arange(1, bf.size + 1)[::-1]

  #tenemos ahora los elementos necesarios para obtener el numero:
    numero = ( (-1)**s / 2 ** (127 - e) ) * ( 1 + (bf/ 2**i_inverted).sum())


    return numero

number32('00111110001000000000000000000000'), number32('00111110001000000000001000010000')

# Commented out IPython magic to ensure Python compatibility.
# %run -i {path}/Act_02/test02.py

"""### Activity 3.0:
1. Write a python script that calculates the double precision number represented by a 64-bits binary.

the name of function should be: 
```
number64(BIN):

```

2. What is the number represented by:

BIN="0 10000000011 1011100100001111111111111111111111111111111111111111"
"""

#realizamos el paso a paso aparte para evitar errores

b= "0100000000111011100100001111111111111111111111111111111111111111"
arr = np.array(list(b)[::-1]).astype(int)
arr

be = arr[52:63]     #para que tome desde la posicion 52 hasta la 63 --> tal que no tome el numero correspondiente al signo
ie = np.arange(11)

s = arr[-1]

be, len(be), ie, s

#ahora, miramos como es la parte fraccional:

bf = arr[:52][::-1]
ifr = np.arange(1, 53)
ifr, len(bf)

#teniendo estos datos ya es posible escribir un código correpondiente a la ecuacion number64

import numpy as np

def number64(BIN):
  b = BIN
  arr = np.array(list(b)[::-1]).astype(int)

  s = arr[-1]

  #parte exponencial
  be = arr[52:63]            #notamos que la parte exponencial va desde las posiciones 52 a la 62 --> por eso se pone hasta 63, para que no tenga en cuenta el signo, la cual es la posicion numero 63
  ie = np.arange(11)
  e= (be * 2 **ie).sum()

  #parte fraccional
  bf = arr[:52][::-1]
  ifr = np.arange(1, 53)

  number = (-1) ** s * (1+ (bf / 2**ifr).sum())  * (2**(e - 1023) )
  
  return number

number64("0100000000111011100100001111111111111111111111111111111111111111")

# Commented out IPython magic to ensure Python compatibility.
# %run -i {path}/Act_02/test03.py