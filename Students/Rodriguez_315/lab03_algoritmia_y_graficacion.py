# -*- coding: utf-8 -*-
"""Lab03_Algoritmia_y_graficacion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rKKashXHGoU0c_3n42u2IshgKG4_FLwi

<a href="https://colab.research.google.com/github/hernansalinas/autogrades/blob/main/Laboratorios_Taller/Lab03_Algoritmia_y_graficacion.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

#Matplot lib
##Grafique la función $f(x) = x^2\sin(x)+\cos(x)$
"""

import matplotlib.pylab as plt
import numpy as np

x = np.linspace(0,2*np.pi,50) #Creamos el dominio de la función
f = lambda x: x**2*np.sin(x) + np.cos(x) #Hacemos la función matemática

plt.figure(figsize=(4,4))
plt.plot(x,f(x),"g--",alpha=0.8, label= "$f(x) = x^2\sin(x)+\cos(x)$")
plt.xlabel("$x$",fontsize=12)
plt.ylabel("F(x)",fontsize=12)
plt.xticks(fontsize=14)
plt.yticks(fontsize=14)
plt.legend(loc=3)
plt.grid()
plt.title("F(x) vs x")

matriz = np.array([[0,1,2,3,4,5],[10,11,12,13,14,15],
         [20,21,22,23,24,25],[30,31,32,33,34,35],
         [40,41,42,43,44,45],[50,51,52,53,54,55]])
matriz

matriz.shape
matriz[4:,4:]

"""#Taller
1.0 Caos numérico en un mapa logístico y errores de punto flotante (Errores de redondeo)

> Un ejemplo clásico de caos,  es el comportamiento no lineal en las interaciones de un mapa logístico 

\begin{equation}
x_{n+1}=f(x_n)=rx_n(1-x_n)
\end{equation}

> con $x\in (0,1)$ y $r\in(0,4)$ se pueden producir varios comportamientos sorprendentes.

Para este problema, será extremadamente útil  ver sus resultados gráficamente; construya listas de números y llame la libreria matplotlib. 


> ### Problema: 
1. Programar la ecuación para el mapa logístico, y  realizar una grafica del valor de xn como funcion de n.

2. Realizar pruebas para un $x_0=0.5$, con valores de r

```
  r = np.array([1.9, 2.9, 3.1, 3.5, 3.9,4.0])
  numpoints = 100, # Numero sugerido de iteraciones
  x0 = 0.5
```

Organizar las gráficas [multiples plot](https://matplotlib.org/stable/gallery/subplots_axes_and_figures/subplots_demo.html)



3. Construye una rutina llamada logist_map en que entrada el valor de r, la condiciones inicial xi y el número de puntos determine la evolución en el punto N.  Prueba implementado las siguientes lineas.

```
Np = 1000
xf = np.zeros(Np)
r  = np.linspace(2.5, 4, Np)
 
for i in range(0, Np): 
  xini = np.random.random()
  x_i = logist_map(r = r[i], xi = xini, N = 1000) 
  xf[i] = x_i
```


4. Realiza un gráfico de:
```
  plt.plot((r-1/r), xf,  ".", markersize = 0.5)
```


5. Encontrar dos formas adicionales de expresar $f(x)$, para estos valores funcionales determinar las mismas gráficas del numeral 3 para cada uno de las formas de escribir la expresión. En este caso se espera que los resultados varien. ¿A que se debe esto?. La respuesta no es inmediata, constulta algunas fuentes para sacar tu propia conclusión.


"""

#Primer punto.
#El tercer punto también se resolvió mediante el primero ya
##que se creó la función tal cual se pide en el punto 3.
import numpy as np
def logist_map(n,x0,r):
  '''
  n es el número de puntos que se tienen.
  r está asociado a la función.
  x0 es la condición inicial
  '''
  matriz = np.zeros(n)
  xactual = x0
  matriz[0] = x0
  for i in range(1,n):
    xn = r*xactual*(1-xactual)
    matriz[i]= xn
    xactual = xn
  return matriz
n = 100
datos = logist_map(n,0.1,0.5)
x = np.arange(n)
plt.plot(x,datos,"g--")
plt.show()

#Punto 2.
#Vamos a hacer la prueba con:
  ##r = np.array([1.9, 2.9, 3.1, 3.5, 3.9,4.0])
  ##numpoints = 100, # Numero sugerido de iteraciones
  ##x0 = 0.5
n = 100
r = np.array([1.9, 2.9, 3.1, 3.5, 3.9,4.0])
x0 = 0.5
ejeX = np.arange(n)
#Para no modificar nuestra función vamos a aplicarla por cada r y guardarla en un arreglo.
r1 = r[0]
r2 = r[1]
r3 = r[2]
r4 = r[3]
r5 = r[4]
r6 = r[5]
datosr1 = logist_map(n,x0,r1)
datosr2 = logist_map(n,x0,r2)
datosr3 = logist_map(n,x0,r3)
datosr4 = logist_map(n,x0,r4)
datosr5 = logist_map(n,x0,r5)

##y ahora pasemos a graficar las 5 r.
import matplotlib.pyplot as plt
fig, axs = plt.subplots(3, 2,figsize=(10,10))
axs[0, 0].plot(ejeX, datosr1, 'tab:purple')
axs[0, 1].plot(ejeX, datosr2, 'tab:orange')
axs[1, 0].plot(ejeX, datosr3, 'tab:green')
axs[1, 1].plot(ejeX, datosr4, 'tab:blue')
axs[2, 0].plot(ejeX, datosr5, 'tab:red')
fig.suptitle('Caos numérico en mapa logístico')
for ax in axs.flat:
    ax.set(xlabel='N', ylabel='xn')

# Mostramos solo los labels de abajo y del lado izquierdo para no saturarlo.
for ax in axs.flat:
    ax.label_outer()

##Prueba del punto 3.
#En este caso se debe crear una matriz 1000x1000 para que el código tenga sentido.
Np = 1000
xf = np.zeros((Np,Np))
r  = np.linspace(2.5, 4, Np)

for i in range(0, Np): 
  xini = np.random.random()
  x_i = logist_map(n = 1000,x0 = xini, r = r[i] ) 
  xf[i] = x_i

#Punto 4: Graficar el xf del punto 3.
plt.plot((r-1/r), xf,  ".", markersize = 0.5, color='purple');

"""**Punto 5.**
Formas adicionales de escribir $xn+1=f(xn)=rxn(1−xn)$
1. $f(x) = rxn-rxn^2$
2. $f(x) = r(xn-xn^2)$

"""

#Para el primer caso transformemos la función l.
def logist_map1(n,x0,r):
  matriz = np.zeros(n)
  xactual = x0
  matriz[0] = x0
  for i in range(1,n):
    xn = r*xactual-r*xactual**2
    matriz[i]= xn
    xactual = xn
  return matriz
 ##Probemos la gráfica del punto 3 nuevamente.
Np = 1000
xf1 = np.zeros((Np,Np))
r1  = np.linspace(2.5, 4, Np)
for i in range(0, Np): 
  xini1 = np.random.random()
  x_i1 = logist_map1(n = 1000,x0 = xini1, r = r1[i] ) 
  xf1[i] = x_i1
plt.plot((r1-1/r1), xf1,  ".", markersize = 0.5, color='green');

#Ahora hagamos los mismo para la segunda forma de la expresión.
def logist_map2(n,x0,r):
  matriz = np.zeros(n)
  xactual = x0
  matriz[0] = x0
  for i in range(1,n):
    xn = r*(xactual-xactual**2)
    matriz[i]= xn
    xactual = xn
  return matriz
 ##Probemos la gráfica del punto 3 nuevamente.
Np = 1000
xf2 = np.zeros((Np,Np))
r2  = np.linspace(2.5, 4, Np)
for i in range(0, Np): 
  xini2 = np.random.random()
  x_i2 = logist_map2(n = 1000,x0 = xini2, r = r2[i] ) 
  xf2[i] = x_i2
plt.plot((r2-1/r2), xf2,  ".", markersize = 0.5, color='red');

"""Notamos que al cambiar la forma de la expresión de dos maneras diferentes, la variación que tiene el resultado es casi que inexistente.

2.0 El algoritmo de gradiente descendente permite encontrar el minimo de funciones en espacios multidimensionales proponiendo puntos en la direccion en la que el gradiente desciende. Para el caso de una dimensión, podemos encontrar el mínimo realizando iteraciones y multiplicando su derivada en cada nuevo punto por una constante $\alpha$

\begin{equation}
x_{i+1}=x_i - \alpha \frac{\mathrm{d}f}{\mathrm{d}x}(x_i)
\end{equation}

Ejemplo:

Sea $f(\omega) = (\omega-1)^2$ , con $\omega \in \mathbb{R} $. El minimo de esta función esta determinado por
\begin{equation}
\frac{\mathrm{d}f}{\mathrm{d}\omega} = 0
\end{equation}

\begin{equation}
\omega = 1
\end{equation}


Para determinar el minimo,  a través del gradiente descendente puede ser aplicada el siguiente algoritmo:
1. Proponer un número aleatorios inicial $\omega_i$
2. Para descender al mínimo de la función, encontremos un  valor para el cual 
la derivada de la función descenciende, asi:
\begin{equation}
\omega_{i+1} = \omega_{i} - \alpha \frac{\mathrm{d}f(\omega_i)}{\mathrm{d}\omega}
\end{equation}

donde, $\alpha$ es conocido como la tasa de aprendizaje del algoritmo. 

3. Evaluar $f(\omega_{i+1})$

4. Iterar hasta encontrar el minimo de la función 


En el caso de la funcion propuesta, asumiendo un valor de $\alpha=1$, tenemos que:

1. Supongamos que $\omega_{0} = 2$, luego :
2. $\omega_{0+1} = 2 - 1 f'(\omega_{0}) =  = 0$
3. $f(0) = 1$
4. $\omega_{1+1} = 0 - 1 f'(\omega_{1}) = 0-1(2(0-1)) =  2$

El valor del $\omega$  despues de un par de iteraciones, no es el esperado, por que no minimiza la función, se debe proponer un tasa de aprendizaje  **$\alpha$** de tal forma que permita descender suavemente para encontrar el minimo. 



**Su tarea será**:

1. Disenar un programa, en el que entrada la función y su derivada, definidas como funciones lambda de python, se determine el valor mínimo de esa función. 
Prueba tu algoritmo para  la función $f(x) = x^2$

2. Realiza el grafico de la funcion y la derivada, especifica la leyenda de cada curva empleando el metodo legend() de matplotlib.
  

3. Analiza como se minimiza la función, gráficando de la funcion en cada punto a iterar,  como funcion del numero de iteraciones. Para dos valores diferentes de la constante alpha (prueba con $\alpha=0.1$, $\alpha=0.01$)
"""

#Primer Punto.
##La función tiene como parámetros la función y su derivada y
##realiza el algoritmo del gradiente descendiente para 1000 puntos
##guardándolos en una matriz de numpy.
def gradiente_descendiente(funcion,derivada,alpha):
  omegai = np.random.random()
  funcionMinimizada = np.empty(1000)
  omegaActual = omegai - alpha*derivada(omegai)
  funcionMinimizada[0] = funcion(omegaActual)
  for i in range(1,1000):
    omegaActual = omegaActual - alpha*derivada(omegaActual)
    funcionOmega = funcion(omegaActual)
    funcionMinimizada[i] = funcionOmega
  return funcionMinimizada

matriz01 = gradiente_descendiente(lambda x: x**2,lambda x: 2*x,0.1)
matriz001 = gradiente_descendiente(lambda x: x**2,lambda x: 2*x,0.01)

#Segundo Punto.
funcion = lambda x: x**2
ejeYFuncion = np.empty(1000)
derivada = lambda x: 2*x
ejeYDerivada = np.empty(1000)
ejeX = np.arange(1000)
for i in range(1000):
  ejeYFuncion[i] = funcion(i)
  ejeYDerivada[i] = derivada(i)
fig, axs = plt.subplots(1, 2, figsize=(10, 5))
axs[0].plot(ejeX, ejeYFuncion, label='$f(x) = x^2$', color='green')
axs[0].set_title('$x^2$')
axs[0].legend()
axs[1].plot(ejeX,ejeYDerivada, label='$f(x)= 2x$')
axs[1].set_title('$2x$')
axs[1].legend()
plt.plot();

#Punto 3.
#Comparemos las gráficas para un alpha = 0.1 y alpha = 0.01
fig, axs = plt.subplots(1, 2, figsize=(10, 5))
axs[0].plot(ejeX,matriz01,color='purple' ,label='alpha=0.1')
axs[0].set_title('Grad Desc. 0.1')
axs[0].legend()
axs[1].plot(ejeX,matriz001,label='alpha=0.01')
axs[1].set_title('Grad Desc. 0.01')
axs[1].legend()
plt.plot();